{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["interface WildcardMatchOptions {\n  separator?: string | boolean\n  flags?: string\n}\n\nfunction escapeRegExpChar(char: string) {\n  if (\n    char === '-' ||\n    char === '^' ||\n    char === '$' ||\n    char === '+' ||\n    char === '.' ||\n    char === '(' ||\n    char === ')' ||\n    char === '|' ||\n    char === '[' ||\n    char === ']' ||\n    char === '{' ||\n    char === '}' ||\n    char === '*' ||\n    char === '?' ||\n    char === '\\\\'\n  ) {\n    return `\\\\${char}`\n  } else {\n    return char\n  }\n}\n\nfunction escapeRegExpString(str: string) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result += escapeRegExpChar(str[i])\n  }\n  return result\n}\n\nfunction compile(pattern: string | string[], options: WildcardMatchOptions): string {\n  if (Array.isArray(pattern)) {\n    let regExpPatterns = pattern.map((p) => `^${compile(p, options)}$`)\n    return `(?:${regExpPatterns.join('|')})`\n  }\n\n  let separator = typeof options.separator === 'undefined' ? true : options.separator\n  let separatorSplitter = ''\n  let separatorMatcher = ''\n  let wildcard = '.'\n\n  if (separator === true) {\n    // In this case forward slashes in patterns match both forward and backslashes in samples\n    separatorSplitter = '/'\n    separatorMatcher = '[/\\\\\\\\]'\n    wildcard = '[^/\\\\\\\\]'\n  } else if (separator) {\n    separatorSplitter = separator\n    separatorMatcher = escapeRegExpString(separatorSplitter)\n\n    if (separatorMatcher.length > 1) {\n      separatorMatcher = `(?:${separatorMatcher})`\n      wildcard = `((?!${separatorMatcher}).)`\n    } else {\n      wildcard = `[^${separatorMatcher}]`\n    }\n  } else {\n    wildcard = '.'\n  }\n\n  // When a separator is explicitly specified in a pattern, it must match _one or more_\n  // separators in a sample, so we use quantifiers. When a pattern doesn't have a trailing\n  // separator, a sample can still optionally have them, so we use different quantifiers\n  // depending on the index of a segment.\n  let requiredSeparator = separator ? `${separatorMatcher}+?` : ''\n  let optionalSeparator = separator ? `${separatorMatcher}*?` : ''\n\n  let segments = separator ? pattern.split(separatorSplitter) : [pattern]\n  let result = ''\n\n  for (let s = 0; s < segments.length; s++) {\n    let segment = segments[s]\n    let nextSegment = segments[s + 1]\n    let currentSeparator = ''\n\n    if (!segment && s > 0) {\n      continue\n    }\n\n    if (separator) {\n      if (s === segments.length - 1) {\n        currentSeparator = optionalSeparator\n      } else if (nextSegment !== '**') {\n        currentSeparator = requiredSeparator\n      } else {\n        currentSeparator = ''\n      }\n    }\n\n    if (separator && segment === '**') {\n      if (currentSeparator) {\n        result += s === 0 ? '' : currentSeparator\n        result += `(?:${wildcard}*?${currentSeparator})*?`\n      }\n      continue\n    }\n\n    for (let c = 0; c < segment.length; c++) {\n      let char = segment[c]\n\n      if (char === '\\\\') {\n        if (c < segment.length - 1) {\n          result += escapeRegExpChar(segment[c + 1])\n          c++\n        }\n      } else if (char === '?') {\n        result += wildcard\n      } else if (char === '*') {\n        result += `${wildcard}*?`\n      } else {\n        result += escapeRegExpChar(char)\n      }\n    }\n\n    result += currentSeparator\n  }\n\n  return result\n}\n\ninterface isMatch {\n  /**\n   * Tests if a sample string matches the pattern(s)\n   *\n   * ```js\n   * isMatch('foo') //=> true\n   * ```\n   */\n  (sample: string): boolean\n\n  /** The compiled regular expression */\n  regexp: RegExp\n\n  /** The original pattern or array of patterns that was used to compile the RegExp */\n  pattern: string | string[]\n\n  /** The options that were used to compile the RegExp */\n  options: WildcardMatchOptions\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n  if (typeof sample !== 'string') {\n    throw new TypeError(`Sample must be a string, but ${typeof sample} given`)\n  }\n\n  return regexp.test(sample)\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns true\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n  pattern: string | string[],\n  options?: string | boolean | WildcardMatchOptions\n) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError(\n      `The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`\n    )\n  }\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    options = { separator: options }\n  }\n\n  if (\n    arguments.length === 2 &&\n    !(\n      typeof options === 'undefined' ||\n      (typeof options === 'object' && options !== null && !Array.isArray(options))\n    )\n  ) {\n    throw new TypeError(\n      `The second argument must be an options object or a string/boolean separator, but ${typeof options} given`\n    )\n  }\n\n  options = options || {}\n\n  if (options.separator === '\\\\') {\n    throw new Error('\\\\ is not a valid separator')\n  }\n\n  let regexpPattern = compile(pattern, options)\n  let regexp = new RegExp(`^${regexpPattern}$`, options.flags)\n\n  let fn = isMatch.bind(null, regexp) as isMatch\n  fn.options = options\n  fn.pattern = pattern\n  fn.regexp = regexp\n  return fn\n}\n\nexport default wildcardMatch\n"],"names":["escapeRegExpChar","char","compile","pattern","options","Array","isArray","map","p","join","separator","separatorSplitter","separatorMatcher","wildcard","str","result","i","length","escapeRegExpString","requiredSeparator","optionalSeparator","segments","split","s","segment","nextSegment","currentSeparator","c","isMatch","regexp","sample","TypeError","test","arguments","Error","regexpPattern","RegExp","flags","fn","bind"],"mappings":"wOAKA,SAASA,EAAiBC,GACxB,MACW,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,MAATA,GACS,OAATA,EAEO,KAAKA,EAELA,EAYX,SAASC,EAAQC,EAA4BC,GAC3C,GAAIC,MAAMC,QAAQH,GAEhB,MAAO,MADcA,EAAQI,KAAI,SAACC,GAAM,MAAA,IAAIN,EAAQM,EAAGJ,UAC3BK,KAAK,SAGnC,IAAIC,OAAyC,IAAtBN,EAAQM,WAAmCN,EAAQM,UACtEC,EAAoB,GACpBC,EAAmB,GACnBC,EAAW,KAEG,IAAdH,GAEFC,EAAoB,IACpBC,EAAmB,UACnBC,EAAW,YAOTA,EANOH,GAETE,EA1BJ,SAA4BE,GAE1B,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAIG,OAAQD,IAC9BD,GAAUf,EAAiBc,EAAIE,IAEjC,OAAOD,EAqBcG,CADnBP,EAAoBD,IAGCO,OAAS,EAEjB,QADXL,EAAmB,MAAMA,aAGd,KAAKA,MAGP,IAab,IANA,IAAIO,EAAoBT,EAAeE,OAAuB,GAC1DQ,EAAoBV,EAAeE,OAAuB,GAE1DS,EAAWX,EAAYP,EAAQmB,MAAMX,GAAqB,CAACR,GAC3DY,EAAS,GAEJQ,EAAI,EAAGA,EAAIF,EAASJ,OAAQM,KACnC,IAAIC,EAAUH,EAASE,GACnBE,EAAcJ,EAASE,EAAI,GAC3BG,EAAmB,GAEvB,GAAKF,KAAWD,EAAI,GAcpB,GAVIb,IAEAgB,EADEH,IAAMF,EAASJ,OAAS,EACPG,EACM,OAAhBK,EACUN,EAEA,IAInBT,GAAyB,OAAZc,EACXE,IACFX,GAAgB,IAANQ,EAAU,GAAKG,EACzBX,GAAU,MAAMF,OAAaa,aAHjC,CAQA,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAQP,OAAQU,KAClC,IAAI1B,EAAOuB,EAAQG,GAEN,OAAT1B,EACE0B,EAAIH,EAAQP,OAAS,IACvBF,GAAUf,EAAiBwB,EAAQG,EAAI,IACvCA,KAGFZ,GADkB,MAATd,EACCY,EACQ,MAATZ,EACIY,OAEHb,EAAiBC,GAI/Bc,GAAUW,GAGZ,OAAOX,EAuBT,SAASa,EAAQC,EAAgBC,GAC/B,GAAsB,iBAAXA,EACT,MAAM,IAAIC,UAAU,uCAAuCD,YAG7D,OAAOD,EAAOG,KAAKF,UAkBrB,SACE3B,EACAC,GAEA,GAAuB,iBAAZD,IAAyBE,MAAMC,QAAQH,GAChD,MAAM,IAAI4B,UACR,0FAA0F5B,YAQ9F,GAJuB,iBAAZC,GAA2C,kBAAZA,IACxCA,EAAU,CAAEM,UAAWN,IAIF,IAArB6B,UAAUhB,aAEW,IAAZb,IACa,iBAAZA,GAAoC,OAAZA,GAAqBC,MAAMC,QAAQF,IAGrE,MAAM,IAAI2B,UACR,2FAA2F3B,YAM/F,GAA0B,QAF1BA,EAAUA,GAAW,IAETM,UACV,MAAM,IAAIwB,MAAM,+BAGlB,IAAIC,EAAgBjC,EAAQC,EAASC,GACjCyB,EAAS,IAAIO,OAAO,IAAID,MAAkB/B,EAAQiC,OAElDC,EAAKV,EAAQW,KAAK,KAAMV,GAI5B,OAHAS,EAAGlC,QAAUA,EACbkC,EAAGnC,QAAUA,EACbmC,EAAGT,OAASA,EACLS"}