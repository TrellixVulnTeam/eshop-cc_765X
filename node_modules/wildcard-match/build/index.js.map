{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["interface WildcardMatchOptions {\n  separator?: string | boolean\n  flags?: string\n}\n\nfunction escapeRegExpChar(char: string) {\n  if (\n    char === '-' ||\n    char === '^' ||\n    char === '$' ||\n    char === '+' ||\n    char === '.' ||\n    char === '(' ||\n    char === ')' ||\n    char === '|' ||\n    char === '[' ||\n    char === ']' ||\n    char === '{' ||\n    char === '}' ||\n    char === '*' ||\n    char === '?' ||\n    char === '\\\\'\n  ) {\n    return `\\\\${char}`\n  } else {\n    return char\n  }\n}\n\nfunction escapeRegExpString(str: string) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result += escapeRegExpChar(str[i])\n  }\n  return result\n}\n\nfunction compile(pattern: string | string[], options: WildcardMatchOptions): string {\n  if (Array.isArray(pattern)) {\n    let regExpPatterns = pattern.map((p) => `^${compile(p, options)}$`)\n    return `(?:${regExpPatterns.join('|')})`\n  }\n\n  let separator = typeof options.separator === 'undefined' ? true : options.separator\n  let separatorSplitter = ''\n  let separatorMatcher = ''\n  let wildcard = '.'\n\n  if (separator === true) {\n    // In this case forward slashes in patterns match both forward and backslashes in samples\n    separatorSplitter = '/'\n    separatorMatcher = '[/\\\\\\\\]'\n    wildcard = '[^/\\\\\\\\]'\n  } else if (separator) {\n    separatorSplitter = separator\n    separatorMatcher = escapeRegExpString(separatorSplitter)\n\n    if (separatorMatcher.length > 1) {\n      separatorMatcher = `(?:${separatorMatcher})`\n      wildcard = `((?!${separatorMatcher}).)`\n    } else {\n      wildcard = `[^${separatorMatcher}]`\n    }\n  } else {\n    wildcard = '.'\n  }\n\n  // When a separator is explicitly specified in a pattern, it must match _one or more_\n  // separators in a sample, so we use quantifiers. When a pattern doesn't have a trailing\n  // separator, a sample can still optionally have them, so we use different quantifiers\n  // depending on the index of a segment.\n  let requiredSeparator = separator ? `${separatorMatcher}+?` : ''\n  let optionalSeparator = separator ? `${separatorMatcher}*?` : ''\n\n  let segments = separator ? pattern.split(separatorSplitter) : [pattern]\n  let result = ''\n\n  for (let s = 0; s < segments.length; s++) {\n    let segment = segments[s]\n    let nextSegment = segments[s + 1]\n    let currentSeparator = ''\n\n    if (!segment && s > 0) {\n      continue\n    }\n\n    if (separator) {\n      if (s === segments.length - 1) {\n        currentSeparator = optionalSeparator\n      } else if (nextSegment !== '**') {\n        currentSeparator = requiredSeparator\n      } else {\n        currentSeparator = ''\n      }\n    }\n\n    if (separator && segment === '**') {\n      if (currentSeparator) {\n        result += s === 0 ? '' : currentSeparator\n        result += `(?:${wildcard}*?${currentSeparator})*?`\n      }\n      continue\n    }\n\n    for (let c = 0; c < segment.length; c++) {\n      let char = segment[c]\n\n      if (char === '\\\\') {\n        if (c < segment.length - 1) {\n          result += escapeRegExpChar(segment[c + 1])\n          c++\n        }\n      } else if (char === '?') {\n        result += wildcard\n      } else if (char === '*') {\n        result += `${wildcard}*?`\n      } else {\n        result += escapeRegExpChar(char)\n      }\n    }\n\n    result += currentSeparator\n  }\n\n  return result\n}\n\ninterface isMatch {\n  /**\n   * Tests if a sample string matches the pattern(s)\n   *\n   * ```js\n   * isMatch('foo') //=> true\n   * ```\n   */\n  (sample: string): boolean\n\n  /** The compiled regular expression */\n  regexp: RegExp\n\n  /** The original pattern or array of patterns that was used to compile the RegExp */\n  pattern: string | string[]\n\n  /** The options that were used to compile the RegExp */\n  options: WildcardMatchOptions\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n  if (typeof sample !== 'string') {\n    throw new TypeError(`Sample must be a string, but ${typeof sample} given`)\n  }\n\n  return regexp.test(sample)\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns true\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n  pattern: string | string[],\n  options?: string | boolean | WildcardMatchOptions\n) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError(\n      `The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`\n    )\n  }\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    options = { separator: options }\n  }\n\n  if (\n    arguments.length === 2 &&\n    !(\n      typeof options === 'undefined' ||\n      (typeof options === 'object' && options !== null && !Array.isArray(options))\n    )\n  ) {\n    throw new TypeError(\n      `The second argument must be an options object or a string/boolean separator, but ${typeof options} given`\n    )\n  }\n\n  options = options || {}\n\n  if (options.separator === '\\\\') {\n    throw new Error('\\\\ is not a valid separator')\n  }\n\n  let regexpPattern = compile(pattern, options)\n  let regexp = new RegExp(`^${regexpPattern}$`, options.flags)\n\n  let fn = isMatch.bind(null, regexp) as isMatch\n  fn.options = options\n  fn.pattern = pattern\n  fn.regexp = regexp\n  return fn\n}\n\nexport default wildcardMatch\n"],"names":[],"mappings":"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"}